<!DOCTYPE html>

<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style>* {
        padding: 0;
        margin: 0;
        border: 0;
        outline: 0;
        overflow: hidden;

    }

    canvas {
        width: 100%;
        background: white;
    }</style>
</head>
<body>

<canvas id="c" width="2000" height="1080" style=""></canvas>

<script>var c = document.querySelector("#c");
c.width = 1920;
c.height = 1080;
var S = Math.sin;
var C = Math.cos;
var T = Math.tan;
var R = function (r, g, b, a) {
  a = a === undefined ? 1 : a;
  return "rgba(" + (r | 0) + "," + (g | 0) + "," + (b | 0) + "," + a + ")";
 };
var x = c.getContext("2d");
var startT = +new Date();
//////////////////////////////////////////

function u21(t) {
  

  x.lineTo(640*t, 0)
x.lineTo(640*t,1000)

x.stroke()


  //c.width|=0;
//c.style.filter=`blur(1px)contrast(99`
  d = (X, Y, l) => {
    x.fillStyle=`rgba(50,${Math.random()*255},50,10%)`;
    x.fillRect(X-l,Y-l,l*4,l*4)
    if(l>0) {
      
      d(X+60, Y, l-2)
      d(X-60, Y, l-2)
      d(X, Y+60, l-2)
      d(X, Y-60, l-2)
      //d(X, Y-10, l-2)
      //d(X-10, Y-10, l-1)
    }
    
  }


  //d(850, 400, 12)
  //x.translate(850,400)
  //x.rotate(0.01)
  //x.translate(-850,-400)
  // f=2e3;
  
  // x.fillStyle='#100100';
  // x.fillRect(0,0,f,f);  
  // x.fillStyle='#ffdf02';
  // for(d=e=0;f--;) {
  //   h=d,
  //   d=e-(!!d|d>>31)*Math.abs(C(z=t/19)*d-S(z))**.2,
  //   e=C(z)+4-h,
  //   x.fillRect(d*64+850,e*64+400,15,15)
  // }

}


// salut
function u20(t) {

    //c.width|=0;

  //r=C(t)*255
  //g=T(t)*255
  //x.fillStyle=R(r,g,255)


  for(i=0;i<2*Math.PI;i+=Math.PI/5) {

    X = 704+S(i)*200*(t%2)*10
    Y = 184+C(i)*200*(t%2)*10
    x.fillRect(X,Y,20+t,20+t)    
  }

  // dy = S(t)*100
  // dx = C(t)*100

  // X = 704 + dx
  // Y = 184 + dy

  //x.fillRect(X,Y,120,120)
  c.style.filter=`blur(5px)contrast(9`
}

// drupel
function u20(t) {

    c.width|=0;

  //r=C(t)*255
  //g=T(t)*255
  //x.fillStyle=R(r,g,255)

  dy = 10/(2-t%2)
  dx = 0

  X = 704 + dx
  Y = 0 + dy

  x.fillRect(X,Y,120,120)
  c.style.filter=`blur(10px)contrast(99`
}

// Life
function u18(t) {
  (B=()=>x.fillStyle=R(1,0,0))()
  for(i=100;i--;x.fillRect(704+(t+i%63)*8,184+(t+i>>5)*8,8,8))
  m=[]

  m2=[]
  

  for(i=4096;i--;) m[Y=i>>6]||=[],m[Y][X=i%64]=x.getImageData(X*8+704,Y*8+184,1,1).data[0]==1

  for(i=4096;i--;) {
    

    w=(X=i%64)?X-1:63
    e=X?X<63?X+1:0:X+1
    n=(Y=i>>6)?Y-1:63
    s=Y?Y<63?Y+1:0:Y+1

    // N=0
    // for(Y2=Y-1;Y2<=Y+1;Y2++)
    //   for(X2=X-1;X2<=X+1;X2++) {
    //     N+=m2[Y2*64+X2]|0;
    //     //debugger
    //   }
    

    AA=m[X][Y];
    
    N = m[w][n] + m[X][n] + m[e][n] + m[w][Y] + m[e][Y] + m[w][s] + m[X][s] + m[e][s],





    x.fillStyle = m[X][Y]&&!(N<2||N>3)||!m[X][Y]&&N==3 ? R(1,0,0) : R(255,255,255)
      

    x.fillRect(704+Y*8,184+X*8,8,8)

      
  }

}


// Transform
function u17(t) {

  c.width|=0;
  //x.fillStyle=`hsla(100,50%,50%,10%)`
 
  offsetX = 704
  offsetY = 184
  rw = 512
  rh = 80

  

  
    
      a1 = Math.random()
      b1 = Math.random()
      c1 = Math.random()
      d1 = Math.random()
      e1 = Math.random()
      f1 = Math.random()

      a1 = C(t)
      b1 = S(t)

      x.setTransform(a1,b1,c1,d1,e1,f1)
      
      x.fillRect(0, 0,100,100)
      //x.resetTransform()
    
  
  
}

// Blur two big circles
function u15(t) {
  for(c.width|=i=2;i--;) {
    x.fillRect(860+200*S(a=t*2+i*3.14),440+99*C(a),250,250)
    c.style.filter=`blur(1vw)contrast(99`,x.fillStyle=R(255*S(t))
  }
  

}

// Magnetic field
function u16(t) {

  c.width|=0;
  for(i=3000;i--;)
    {
      x.fillRect(0,0,5,10);
      X=i % 63,
      Y=i >> 6,
      tt = (t+(X-32)*(Y-1)/9),
      s=tt - tt % (Math.PI/4);
      
      

      a1 = C(s)
      b1 = S(s)
      c1 = -b1
      d1 = a1
      e1 = X*30
      f1 = Y*30
      x.setTransform(a1,b1,c1,d1,e1,f1)
    }

  // for(x = 0; x < 32; x++) {
  //   for(y = 0; y < 32; y++) {
  //     x.fillRect(x * , offsetY - rh/2,rw,rh)
  //   }
  // }


}

// Reqctangle, rotating around center
function u14(t) {

  x.fillStyle=`hsla(100,50%,50%,50%)`

  // I = x.createImageData(1,1);

  // I.data[0] = 255
  // I.data[1] = 0
  // I.data[2] = 1
  // I.data[3] = 255
 
  offsetX = 704
  offsetY = 184
  rw = 512
  rh = 80

  
  // x.putImageData(I, Math.ceil(t*100), 1)
  //x.fillRect(t*10, 100+Math.random()*100,8,8)
  x.fillRect(offsetX - rw/2, offsetY - rh/2,rw,rh)
  //x.translate(50,0)
  x.translate(offsetX, offsetY)
  x.rotate(0.1)
  x.translate(-offsetX, -offsetY)
  //x.transform(1, .2, .8, 1, 0, 0);
}


// Life
function u18(t) {
  offsetX = 704
  offsetY = 184
  dotsInField = 64
  dotSize = 8


  x.fillStyle=R(200,0,0)

  
  for(i=100;i--;x.fillRect(offsetX + (t+i%63) * dotSize, offsetY + (t+i>>5) * dotSize, dotSize, dotSize))

  

  var matrix = [];
  
  for (row=0;row<dotsInField;row++){
    matrix[row] = []
    for (col=0;col<dotsInField;col++) {
      red = x.getImageData(col * dotSize + offsetX, row * dotSize + offsetY, 1, 1).data[0]
      matrix[row][col] = 0 + (red === 200);
      
    }
  }


   for (X=0;X<dotsInField;X++){
    for (Y=9;Y<dotsInField;Y++) {
      if (X == 0) {
        w = dotsInField - 1
        e = X + 1
      } else if (X == dotsInField - 1) {
        w = X - 1
        e = 0
      } else {
        w = X - 1
        e = X + 1
      }

      if (Y == 0) {
        n = dotsInField - 1
        s = Y + 1
      } else if (Y == dotsInField - 1) {
        n = Y - 1
        s = 0
      } else {
        n = Y - 1
        s = Y + 1
      }


      area = [
        matrix[w][n], matrix[X][n], matrix[e][n],
        matrix[w][Y], matrix[X][Y], matrix[e][Y],
        matrix[w][s], matrix[X][s], matrix[e][s],
      ]

      neigbhorsCount = area.reduce((memo, v) => (memo + v)) - area[4];

      
      




      x.fillStyle=`rgb(255,255,255)`
      if (area[4] == 1){
        if (neigbhorsCount < 2 || neigbhorsCount > 3) x.fillStyle=R(255,255,255)
        else x.fillStyle=R(200,0,0)
      }
        
      else if (neigbhorsCount == 3) x.fillStyle=R(200,0,0)


//////////////////////////////

      U1=(area[4]==1)
      U2=(neigbhorsCount < 2 || neigbhorsCount > 3)
      U3=(neigbhorsCount == 3)

      (U1&&U2)||(!U1&&!U3) (x.fillStyle=R(255,255,255))
      (U1&&!U2)||(!U1&&U3) (x.fillStyle=R(1,0,0))

      
      if (area[4] == 1){
        if (neigbhorsCount < 2 || neigbhorsCount > 3) x.fillStyle=R(255,255,255)
        else x.fillStyle=R(200,0,0)
      }
        
      else 
        if (neigbhorsCount == 3) x.fillStyle=R(200,0,0)
        else x.fillStyle=R(255,255,255)


/////////////////////////////
      //x.fillStyle = area[4]==1?(neigbhorsCount < 2 || neigbhorsCount > 3)?R(255,255,255):R(200,0,0)

      x.fillRect(Y*dotSize+offsetX,X*dotSize+offsetY,dotSize,dotSize);

      
      
    }
  }

}


// https://www.dwitter.net/d/22513
function u3(t) {
  f=(X,Y,n=120)=>{
    return T(C(Y)**3)<1.5 ? f(X*X-Y*Y, 2*X*Y+.7, n-3) : n
  }
  for(i=2e3;i--;) {
    X = i
    Y = t*120
    W = f(i/4e4-.3,t/300+.21)/75
    H = 2
    x.fillRect(X, Y, W, H)
  }
}

// Dynamic Mosaic
function u12(t) {

  eval(unescape(escape("𢐽𮀮𨱲𩑡𭁥𢑭𨑧𩑄𨑴𨐨𜠵𝠬𜠵𝠩𞱦𫱲𚁩👉𛡤𨑴𨐮𫁥𫡧𭁨𞱩𛐽𝀻𚐨𚁴𚠹𚰨𦀽𚁦👍𨑴𪀮𩡬𫱯𬠩𚀨𪐥𜐰𜠴𚐯𝀩𚑞𚁙👦𚀨𪐯𜠵𝠩𛰴𚐩𚐥𜰽🐨𦁞𦐫𭀪𞐩𙐳𚐦𙠨𢐮𩁡𭁡𦱩𚰳𧐽𜠵𝐩𞱸𛡰𭑴𢑭𨑧𩑄𨑴𨐨𢐬𜀬𜀩").replace(/uD./g,'')))


  return

I=x.createImageData(256,256);for(i=I.data.length;i-=4;)((t*9+(X=(f=Math.floor)((i%1024)/4))^(Y=f((i/256)/4)))%3==(X^Y+t*9)%3)&&(I.data[i+3]=255);x.putImageData(I,0,0)

  return

  s = 512 // size in pixels
  m = 1 // megaPixel size
  b = 4 //bites in pixel

  I = x.createImageData(s, s)

  for (let i = 0; i < I.data.length; i += b) {
    let X = Math.floor((i % (s * b)) / m / b);
    let Y = Math.floor((i / s) / m / b);

    if((t*9+X^Y)%3==(X^Y+t*9)%3) {
      I.data[i + 0] = 0;        // R value
      I.data[i + 1] = 0;        // G value
      I.data[i + 2] = 0;  // B value
      I.data[i + 3] = 128;      // A value
    }

  }

  x.putImageData(I, 20, 20);
  x.globalCompositeOperation='xor'
}


// Alien fire
function u12(t) {
  
  c.width|=0;for(i=0;i<128;i++)for(j=0;j<64;j++)(t*9+i^j)%3==0&&(x.fillStyle=`hsl(${60-i/2},99%,${99-i/2}%)`)+x.fillRect(j*8+704,i*8+184,8,8)


}

/* Draw scaled pixels with putImageData
*/
function u11(t) {
  //c.width |= 0

  s = 256 // size in pixels
  m = 16 // megaPixel size
  b = 4 //bites in pixel

  I = x.createImageData(s, s)

  for(Y=0; Y<s/m; Y++) {
    for(X=0; X<s/m; X++) {
      for(DY=0; DY<m * b*s; DY+=s*b) {
        for(DX=0; DX<m * b; DX+=b) {
          j = DX + DY + Y * s * b * m + X * b * m;

          I.data[j + 0] = ((X+Y)%2) ? 200 : 0;        // R value
          I.data[j + 1] = ((X+Y)%2) ? 100 : 0;        // G value
          I.data[j + 2] = 0;  // B value
          I.data[j + 3] = 255;      // A value
        }
      }
    }
  }


  x.putImageData(I, 20, 20);
}

/* Draw scaled pixels with putImageData
   Gets every byte of ImageData and checks should fill it or not
*/
function u9(t) {
  s = 256 // size in pixels
  m = 16 // megaPixel size
  b = 4 //bites in pixel

  I = x.createImageData(s, s)

  for (let i = 0; i < I.data.length; i += b) {
    let X = Math.floor((i % (s * b)) / m / b);
    let Y = Math.floor((i / s) / m / b);

    if ((X+Y)%2) {
      I.data[i + 0] = 0;        // R value
      I.data[i + 1] = 0;        // G value
      I.data[i + 2] = 0;  // B value
      I.data[i + 3] = 255;      // A value
    }
  }

  x.putImageData(I, 20, 20);
}

function u(t) {
  size = 256
  imageData = x.createImageData(size, size);

  for (let i = 0; i < imageData.data.length; i += 4) {
    let X = (i/4 % 128);
    let Y = Math.ceil(i/ 4 / 128);

    if (X& Y % Math.ceil(t*5)) {
        imageData.data[i + 0] = Math.ceil(t*100)%255;        // R value
        imageData.data[i + 1] = i%255;        // G value
        imageData.data[i + 2] = 0;  // B value
        imageData.data[i + 3] = 255;      // A value
    }

  }

  x.putImageData(imageData, 20, 20);
  //x.rotate(0.1)
}





// function u(t) {
//   c.width |= 0

//   for (i=0;i<64;i++){
//     for (j=0;j<64;j++) {
//       if ((i * S(t*2)*10 > j * C(t))) {

//         x.fillRect(i*8+704,j*8+184,8,8);

//       }
//     }
//   }
// }



function loop() {
  requestAnimationFrame(loop);
  u((new Date() - startT) / 1000);
};

loop();
//setInterval(() => { u((new Date() - startT) / 1000) }, 100)
</script>
</body>
</html>