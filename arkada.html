<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Космический корабль</title>
    <style>
        canvas {
            display: block;
            background-color: #000;
            margin: 0 auto;
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    let gameOver = false; // Переменная для отслеживания состояния игры

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Установка размеров canvas
    canvas.width = 800;
    canvas.height = 600;

    // Корабль
    const ship = {
      x: 50,
      y: canvas.height / 2,
      width: 20,
      height: 10,
      speed: 3,
      moveUp: false,
      moveDown: false
    };

    // Пули
    const bullets = [];
    const bulletSpeed = 10;

    // Фон
    let backgroundX = 0;
    const backgroundSpeed = 2;

    // Текстура земли
    let groundY = canvas.height - 50; // Позиция земли от низа канваса
    const groundHeight = 50; // Высота земли

    // Враги
    const enemies = [];
    const enemySpeed = 2;

    // Ракета
    const rocketPixels = [
      [0, 0, 1, 1, 1, 1, 0],
      [2, 2, 0, 1, 1, 1, 1],
      [0, 0, 1, 1, 1, 1, 0],
    ];

    // Размер пикселя
    const pixelSize = 5;

    let isOrange = true; // Переменная для переключения цвета огня

    // Переключаем цвет огня каждые 500 мс
    setInterval(function() {
      isOrange ^= true;
    }, 100);

    function drawShip() {
      for (let i = 0; i < rocketPixels.length; i++) {
        for (let j = 0; j < rocketPixels[i].length; j++) {
          if (rocketPixels[i][j] === 1) {
            ctx.fillStyle = 'white';
            ctx.fillRect(ship.x + j * pixelSize, ship.y + i * pixelSize, pixelSize, pixelSize);
          } else if (rocketPixels[i][j] === 2) {
            ctx.fillStyle = isOrange ? 'orange' : 'red';
            ctx.fillRect(ship.x + j * pixelSize, ship.y + i * pixelSize, pixelSize, pixelSize);
          }
        }
      }
    }

    function drawBullet(bullet) {
      ctx.fillStyle = 'yellow';
      ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
    }

    function updateBackground() {
      backgroundX -= backgroundSpeed;
      if (backgroundX <= -canvas.width) {
        backgroundX = 0;
      }
    }

    function updateBullets() {
      for (let i = 0; i < bullets.length; i++) {
        bullets[i].x += bulletSpeed;
        // Удаляем пулю, если она вышла за пределы канваса
        if (bullets[i].x > canvas.width) {
          bullets.splice(i, 1);
          i--;
        }
      }
    }

    function drawBackground() {
      ctx.fillStyle = '#000';
      ctx.fillRect(backgroundX, 0, canvas.width, groundY);
      ctx.fillRect(backgroundX + canvas.width, 0, canvas.width, groundY);
    }

    function createEnemy() {
      let enemy = {
        x: canvas.width,
        y: Math.random() * (canvas.height - groundHeight),
        width: 10,
        height: 10,
        speed: enemySpeed
      };
      enemies.push(enemy);
    }

    // Пиксель-арт врага
    const enemyPixels = [
      [0, 1, 1],
      [1, 1, 1],
      [0, 1, 1],
    ];

    function drawEnemy(enemy) {
      for (let i = 0; i < enemyPixels.length; i++) {
        for (let j = 0; j < enemyPixels[i].length; j++) {
          if (enemyPixels[i][j] === 1) {
            ctx.fillStyle = 'red';
            ctx.fillRect(enemy.x + j * pixelSize, enemy.y + i * pixelSize, pixelSize, pixelSize);
          }
        }
      }
    }

    function updateEnemies() {
      for (let i = 0; i < enemies.length; i++) {
        enemies[i].x -= enemies[i].speed;
        // Удаляем врага, если он вышел за пределы канваса
        if (enemies[i].x + enemies[i].width < 0) {
          enemies.splice(i, 1);
          i--;
        }
      }
    }

    function checkBulletEnemyCollision() {
      for (let i = 0; i < bullets.length; i++) {
        for (let j = 0; j < enemies.length; j++) {
          let bullet = bullets[i];
          let enemy = enemies[j];
          if (bullet.x < enemy.x + enemy.width &&
            bullet.x + bullet.width > enemy.x &&
            bullet.y < enemy.y + enemy.height &&
            bullet.y + bullet.height > enemy.y) {
            // Столкновение произошло, удаляем пулю и врага
            bullets.splice(i, 1);
            enemies.splice(j, 1);
            score++; // Увеличиваем счет
            createExplosion(enemy.x, enemy.y); // Создаем взрыв
            return;
          }
        }
      }
    }

    function checkShipEnemyCollision() {
      for (let i = 0; i < enemies.length; i++) {
        let enemy = enemies[i];
        if (ship.x < enemy.x + enemy.width &&
          ship.x + ship.width > enemy.x &&
          ship.y < enemy.y + enemy.height &&
          ship.y + ship.height > enemy.y) {
          // Столкновение произошло, игра заканчивается
          document.getElementById('restartButton').style.display = 'block'; // Показываем кнопку "Начать заново"
          gameOver = true;
          return;
        }
      }
    }

    // Звезды
    const stars = [];
    const starSpeed = 0.5;

    function createStar() {
      let star = {
        x: Math.random() * canvas.width,
        y: Math.random() * (canvas.height - groundHeight),
        radius: Math.random() * 2, // радиус звезды
        speed: starSpeed
      };
      stars.push(star);
    }

    function drawStar(star) {
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2, false);
      ctx.fill();
    }

    function updateStars() {
      for (let i = 0; i < stars.length; i++) {
        stars[i].x -= stars[i].speed;
        // Если звезда вышла за пределы канваса слева, удаляем ее
        if (stars[i].x + stars[i].radius < 0) {
          stars.splice(i, 1);
          i--;
        }
      }
    }

    // Количество сбитых врагов
    let score = 0;

    function drawScore() {
      ctx.fillStyle = 'white';
      ctx.font = '20px Arial';
      ctx.fillText('Score: ' + score, canvas.width - 100, 30);
    }

    // Частицы взрыва
    const particles = [];

    function createExplosion(x, y) {
      // Создаем 10 частиц для каждого взрыва
      for (let i = 0; i < 10; i++) {
        let particle = {
          x: x,
          y: y,
          width: 5,
          height: 5,
          speed: Math.random() * 5 + 1, // Скорость частицы
          direction: Math.random() * Math.PI * 2 // Направление частицы
        };
        particles.push(particle);
      }
    }

    function drawParticle(particle) {
      ctx.fillStyle = 'orange';
      ctx.fillRect(particle.x, particle.y, particle.width, particle.height);
    }

    function updateParticles() {
      for (let i = 0; i < particles.length; i++) {
        particles[i].x += particles[i].speed * Math.cos(particles[i].direction);
        particles[i].y += particles[i].speed * Math.sin(particles[i].direction);
        particles[i].speed *= 0.99; // Уменьшаем скорость частицы (имитация сопротивления воздуха)
        // Удаляем частицу, если ее скорость становится слишком маленькой
        if (particles[i].speed < 0.81) {
          particles.splice(i, 1);
          i--;
        }
      }
    }

    // В функции draw добавляем отрисовку счета
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      stars.forEach(drawStar);
      drawShip();
      bullets.forEach(drawBullet);
      enemies.forEach(drawEnemy);
      particles.forEach(drawParticle); // Отрисовываем частицы
      drawScore(); // Отрисовываем счет
    }

    function update() {
      if (ship.moveUp && ship.y > 0) ship.y -= ship.speed;
      if (ship.moveDown && ship.y < canvas.height - ship.height) ship.y += ship.speed;

      updateBackground();
      updateStars(); // Обновляем звезды
      updateBullets();
      updateEnemies(); // Обновляем врагов
      updateParticles(); // Обновляем взрывы
      checkBulletEnemyCollision(); // Проверяем столкновение пуль и врагов
      checkShipEnemyCollision();
    }

// В gameLoop добавляем вызов функции createEnemy каждые 2 секунды
    let lastEnemyCreationTime = Date.now();
    let lastStarCreationTime = Date.now();
    let scoreForLastEnemyCreation = score < 100 ? score : 100;
    let enemyCreationInterval = 2000 - scoreForLastEnemyCreation * 10; // Уменьшаем интервал создания врагов в зависимости от счета

    function gameLoop() {
      if (gameOver) return; // Если игра завершена, прерываем выполнение gameLoop

      let now = Date.now();
      if (now - lastEnemyCreationTime > enemyCreationInterval) { // 2000 мс = 2 сек
        createEnemy();
        lastEnemyCreationTime = now;
      }
      if (now - lastStarCreationTime > 100) { // 100 мс
        createStar();
        lastStarCreationTime = now;
      }

      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // Обработчики клавиатуры
    document.addEventListener('keydown', function(e) {
      if (e.key === 'ArrowUp') ship.moveUp = true;
      if (e.key === 'ArrowDown') ship.moveDown = true;
      if (e.key === 'ArrowRight') {
        bullets.push({ x: ship.x + ship.width, y: ship.y + ship.height / 2, width: 10, height: 5 });
      }
    });

    document.addEventListener('keyup', function(e) {
      if (e.key === 'ArrowUp') ship.moveUp = false;
      if (e.key === 'ArrowDown') ship.moveDown = false;
    });

    document.getElementById('restartButton').addEventListener('click', function() {
      // Сбрасываем игру
      enemies.length = 0;
      bullets.length = 0;
      score = 0;
      ship.x = 50;
      ship.y = canvas.height / 2;
      gameOver = false;
      // Начинаем игру снова
      gameLoop();
      // Скрываем кнопку "Начать заново"
      this.style.display = 'none';
    });

    gameLoop();
  });



</script>
<button id="restartButton" style="display: none;">Начать заново</button>

</body>
</html>
